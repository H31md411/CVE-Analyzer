import tkinter as tk
from tkinter import scrolledtext, messagebox, ttk
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
import os
import requests
from langchain_community.llms.ollama import Ollama
from dotenv import load_dotenv
import threading
import openai
import subprocess
import platform
import logging
from typing import List, Tuple, Optional, Callable, Union
from PIL import Image, ImageTk

# Load environment variables from a .env file
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constants
DARK_BG = '#2E2E2E'
DARKER_BG = '#1E1E1E'
LIGHT_BG = '#F0F0F0'
LIGHTER_BG = '#FFFFFF'
DARK_TEXT_COLOR = 'white'
LIGHT_TEXT_COLOR = 'black'
BUTTON_COLOR = '#4CAF50'
REPORTS_DIRECTORY = 'reports'
CVE_API_URL = "https://cve.circl.lu/api/last/10"  # URL to fetch the last 100 CVEs

# Initialize LLaMA model
def create_llm_llama() -> Optional[Ollama]:
    try:
        return Ollama(
            model="llama3.1",
            base_url="http://localhost:11434"
        )
    except Exception as e:
        logging.error(f"Error creating LLaMA model: {str(e)}")
        return None

# Initialize OpenAI GPT
def create_llm_openai():
    openai.api_key = os.getenv('OPENAI_API_KEY')
    return openai



def query_llm(prompt: str, llm) -> str:
    """Query the language model with the given prompt."""
    try:
        if isinstance(llm, Ollama):
            response = llm.invoke(prompt)
            return response if isinstance(response, str) else response.get('text', 'No text returned from LLaMA')
        elif llm is openai:
            response = llm.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are a cybersecurity expert, specialized in analyzing CVEs and their potential impact to companies."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1500
            )
            return response.choices[0].message.content.strip()
            
        else:
            return 'Unsupported LLM type'
    except Exception as e:
        logging.error(f"Error querying LLM: {str(e)}")
        return f"Error querying LLM: {str(e)}"

def analyze_cve(cve_id: str, llm_instance, callback, progress_callback: Callable[[int], None]):
    """Analyze the given CVE ID using the specified language model."""
    def worker():
        try:
            progress_callback(10)
            cve_url = f"https://cve.circl.lu/api/cve/{cve_id}"
            web_scraper = WebScrapingTool()
            cve_info = web_scraper.scrape(cve_url)
            
            if "Error" in cve_info:
                callback(cve_info)
                return
            
            progress_callback(50)
            llm_prompt = (
                f"You are a cybersecurity expert, specialized in analyzing CVEs and their potential impact to companies. Analyze the following CVE information and provide a detailed report:\n{cve_info}\n"
                "Please include a summary of the CVE, potential impacts, and recommended remediation actions."
            )
            llm_report = query_llm(llm_prompt, llm_instance)
            
            if "Error" in llm_report:
                callback(llm_report)
                return
            
            progress_callback(100)
            callback(llm_report)
        except Exception as e:
            logging.error(f"Error in analyze_cve: {str(e)}")
            callback(f"Error analyzing CVE: {str(e)}")
    
    threading.Thread(target=worker).start()

def save_report(self, *args):
    """Save the generated report as a text file and PDF."""
    cve_id = self.cve_id_entry.get()
    report = self.text_area.get(1.0, tk.END)
    if not cve_id or not report.strip():
        messagebox.showerror("Error", "Please analyze a CVE and generate a report first.")
        return
    
    text_file_path = save_report(report, cve_id)
    pdf_file_path = save_pdf(report, cve_id)
    self.wait_label.config(text=f"Report saved as {text_file_path} and {pdf_file_path}.")
    
    # Update recent reports list
    recent_reports = load_recent_reports()
    self.recent_reports_listbox.delete(0, tk.END)
    for report in recent_reports:
        self.recent_reports_listbox.insert(tk.END, report)

def save_pdf(report: str, cve_id: str) -> str:
    """Save the report as a PDF file with enhanced formatting."""
    file_path = os.path.join(REPORTS_DIRECTORY, f'{cve_id}.pdf')
    doc = SimpleDocTemplate(file_path, pagesize=letter)
    styles = getSampleStyleSheet()
    style_title = ParagraphStyle(
        name='Title',
        parent=styles['Title'],
        fontName='Helvetica-Bold',
        fontSize=16,
        spaceAfter=12,
        textColor=colors.darkblue,
        alignment=1
    )
    style_heading = ParagraphStyle(
        name='Heading',
        parent=styles['Heading2'],
        fontName='Helvetica-Bold',
        fontSize=14,
        spaceAfter=6,
        textColor=colors.darkblue
    )
    style_normal = ParagraphStyle(
        name='Normal',
        parent=styles['Normal'],
        fontName='Helvetica',
        fontSize=12,
        leading=14,
        spaceAfter=6,
        textColor=colors.black
    )
    
    elements = []
    title = Paragraph(f"CVE Analysis Report: {cve_id}", style_title)
    elements.append(title)
    elements.append(Spacer(1, 12))
    
    # Split report into sections
    sections = report.split('\n\n')
    for section in sections:
        if ':' in section:
            heading, content = section.split(':', 1)
            elements.append(Paragraph(heading.strip(), style_heading))
            elements.append(Paragraph(content.strip(), style_normal))
        else:
            elements.append(Paragraph(section, style_normal))
        elements.append(Spacer(1, 6))
    
    elements.append(Spacer(1, 12))
    elements.append(Paragraph(f"Generated by CVE Analyzer Tool - Marcel Graewer 2024", style_normal))
    
    doc.build(elements)
    return file_path

def load_recent_reports() -> List[str]:
    """Load the list of recent reports."""
    if not os.path.exists(REPORTS_DIRECTORY):
        os.makedirs(REPORTS_DIRECTORY)
    
    # Filter only .pdf files
    recent_reports = [f for f in os.listdir(REPORTS_DIRECTORY) if f.endswith('.pdf')]
    # Sort by modification time
    recent_reports = sorted(recent_reports, key=lambda x: os.path.getmtime(os.path.join(REPORTS_DIRECTORY, x)), reverse=True)
    return recent_reports[:50]


def open_pdf_report(file_path: str):
    """Open the PDF report using the default PDF viewer."""
    try:
        if platform.system() == 'Darwin':  # macOS
            subprocess.run(['open', file_path])
        elif platform.system() == 'Windows':  # Windows
            os.startfile(file_path)
        elif platform.system() == 'Linux':  # Linux
            subprocess.run(['xdg-open', file_path])
        else:
            messagebox.showerror("Error", "Unsupported OS for opening PDFs.")
    except Exception as e:
        logging.error(f"Failed to open PDF file: {file_path}. Error: {str(e)}")
        messagebox.showerror("Error", f"Failed to open PDF file: {file_path}. Error: {str(e)}")

def fetch_all_cves() -> List[Tuple[str, str]]:
    """Fetch the last CVEs from the CVE database."""
    try:
        response = requests.get(CVE_API_URL)
        response.raise_for_status()
        cve_data = response.json()
        return [(entry['id'], entry['summary']) for entry in cve_data]
    except requests.RequestException as e:
        logging.error(f"Error fetching CVEs: {str(e)}")
        return []

class WebScrapingTool:
    def scrape(self, url: str) -> Union[dict, str]:
        """Scrape the content from the given URL."""
        try:
            response = requests.get(url)
            response.raise_for_status()
            return response.json()  # assuming API returns JSON
        except requests.RequestException as e:
            logging.error(f"Error scraping {url}: {str(e)}")
            return f"Error scraping {url}: {str(e)}"

class CVEAnalyzerApp:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("CVE Analyzer Tool")
        self.configure_theme()
        
        # Set window icon
        self.window_icon = Image.open("icon.png")
        self.window_icon = ImageTk.PhotoImage(self.window_icon)
        self.root.iconphoto(True, self.window_icon)
        # Initialize LLM
        self.llm_type = tk.StringVar(value='openai')  # Default to LLaMA
        self.llm_instance = create_llm_openai()  # Default to LLaMA
        
        # Load all CVEs
        self.all_cves = fetch_all_cves()
        
        self.create_gui_elements()
        
    def configure_theme(self, dark_mode: bool = True):
        self.bg_color = '#2E2E2E'
        self.text_color = 'white'
        self.entry_bg = '#1E1E1E'
        self.radio_bg = '#3E3E3E' 
        self.radio_indicator_color = '#000000'  
        self.root.configure(bg=self.bg_color)
        
    def create_gui_elements(self):
        """Create and arrange GUI elements."""
        self.configure_grid()
        self.create_title()
        self.create_input_area()
        self.create_llm_selection()
        self.create_cve_list()
        self.create_text_area()
        self.create_save_button()
        self.create_recent_reports_list()
        self.create_wait_label()
        self.create_progress_bar()

    
    def configure_grid(self):
        """Configure the grid layout."""
        for i in range(3):
            tk.Grid.columnconfigure(self.root, i, weight=1)
        for i in range(8):
            tk.Grid.rowconfigure(self.root, i, weight=1)
    
    def create_title(self):
        """Create the title label."""
        self.title_label = tk.Label(self.root, text="CVE Analyzer Tool", font=("Arial", 16), bg=self.bg_color, fg=self.text_color)
        self.title_label.grid(row=0, column=0, columnspan=3, padx=10, pady=10, sticky='w')
    
    def create_input_area(self):
        """Create the input area for CVE ID with filtering."""
        self.label = tk.Label(self.root, text="Enter CVE ID or select from the list:", bg=self.bg_color, fg=self.text_color)
        self.label.grid(row=1, column=0, padx=10, pady=10, sticky='w')
        
        self.cve_id_entry = tk.Entry(self.root, bg=self.entry_bg, fg=self.text_color)
        self.cve_id_entry.grid(row=1, column=1, padx=10, pady=10, sticky='we')
        self.cve_id_entry.bind('<KeyRelease>', self.filter_cve_list)
        
        self.analyze_button = tk.Button(self.root, text="Analyze CVE", command=self.analyze_cve, bg=BUTTON_COLOR, fg=self.text_color)
        self.analyze_button.grid(row=1, column=2, padx=10, pady=10, sticky='w')
    
    def create_cve_list(self):
        """Create the CVE listbox to display CVEs."""
        self.cve_listbox = tk.Listbox(self.root, bg=self.entry_bg, fg=self.text_color, selectbackground=BUTTON_COLOR)
        self.cve_listbox.grid(row=2, column=0, columnspan=4, padx=10, pady=10, sticky='nsew')
        self.cve_listbox.bind('<<ListboxSelect>>', self.on_cve_select)
        
        # Insert CVEs into listbox
        for cve_id, summary in self.all_cves:
            self.cve_listbox.insert(tk.END, f"{cve_id}: {summary}")
    
    def filter_cve_list(self, event):
        """Filter the CVE list based on input."""
        filter_text = self.cve_id_entry.get().lower()
        self.cve_listbox.delete(0, tk.END)
        
        for cve_id, summary in self.all_cves:
            if filter_text in cve_id.lower() or filter_text in summary.lower():
                self.cve_listbox.insert(tk.END, f"{cve_id}: {summary}")
    
    def on_cve_select(self, event):
        """Handle CVE selection from the list."""
        selection = self.cve_listbox.curselection()
        if selection:
            cve_data = self.cve_listbox.get(selection[0])
            cve_id = cve_data.split(":")[0]
            self.cve_id_entry.delete(0, tk.END)
            self.cve_id_entry.insert(0, cve_id)
    
    def create_llm_selection(self):
        """Erstelle die LLM-Auswahl mit Radio Buttons."""
        self.llm_frame = tk.Frame(self.root, bg=self.bg_color)
        self.llm_frame.grid(row=1, column=3, columnspan=1, padx=10, pady=10, sticky='w')
    
        self.llm_label = tk.Label(self.llm_frame, text="Select LLM:", bg=self.bg_color, fg=self.text_color)
        self.llm_label.grid(row=0, column=0, padx=10, pady=10, sticky='w')
    
        self.llm_llama_radio = tk.Radiobutton(
            self.llm_frame,
            text="LLaMA",
            variable=self.llm_type,
            value='llama',
            command=self.on_llm_change,
            bg=self.radio_bg,
            fg=self.text_color,
            selectcolor=self.radio_indicator_color,  
            indicatoron=1,
            width=15
        )
        self.llm_llama_radio.grid(row=1, column=0, padx=10, pady=5, sticky='w')
    
        self.llm_openai_radio = tk.Radiobutton(
            self.llm_frame,
            text="OpenAI",
            variable=self.llm_type,
            value='openai',
            command=self.on_llm_change,
            bg=self.radio_bg,
            fg=self.text_color,
            selectcolor=self.radio_indicator_color,  
            indicatoron=1,
            width=15
        )
        self.llm_openai_radio.grid(row=2, column=0, padx=10, pady=5, sticky='w')
    
    def on_llm_change(self):
        """Handle changes in LLM selection."""
        llm_type = self.llm_type.get()
        if llm_type == 'llama':
            self.llm_instance = create_llm_llama()
        elif llm_type == 'openai':
            self.llm_instance = create_llm_openai()
    
    def on_llm_change(self, *args):
        """Handle changes in LLM selection."""
        llm_type = self.llm_type.get()
        if llm_type == 'llama':
            self.llm_instance = create_llm_llama()
        elif llm_type == 'openai':
            self.llm_instance = create_llm_openai()
    
    def create_text_area(self):
        """Create the scrolled text area for displaying the report."""
        self.text_area = scrolledtext.ScrolledText(self.root, wrap=tk.WORD, bg=self.entry_bg, fg=self.text_color)
        self.text_area.grid(row=4, column=0, columnspan=4, padx=10, pady=10, sticky='nsew')
    
    def create_save_button(self):
        """Create the save button with an icon."""
        self.save_button_icon = Image.open("pdf.png")
        self.save_button_icon = self.save_button_icon.resize((24, 24), Image.Resampling.BICUBIC)
        self.save_button_icon = ImageTk.PhotoImage(self.save_button_icon)
        
        self.save_button = tk.Button(
            self.root,
            text="Save Report",
            command=self.save_report_initial,
            bg=BUTTON_COLOR,
            fg=self.text_color,
            image=self.save_button_icon,
            compound=tk.LEFT  # Text will be shown next to the icon
        )
        self.save_button.grid(row=5, column=3, padx=10, pady=10, sticky='e')
    
    def create_recent_reports_list(self):
        """Create the listbox to display recent reports."""
        self.recent_reports_label = tk.Label(self.root, text="Recent Reports:", bg=self.bg_color, fg=self.text_color)
        self.recent_reports_label.grid(row=5, column=0, padx=10, pady=10, sticky='w')
        
        self.recent_reports_listbox = tk.Listbox(self.root, bg=self.entry_bg, fg=self.text_color, selectbackground=BUTTON_COLOR)
        self.recent_reports_listbox.grid(row=6, column=0, columnspan=2, padx=10, pady=10, sticky='nsew')
        self.recent_reports_listbox.bind('<<ListboxSelect>>', self.on_recent_report_select)
        
        # Populate with recent reports
        recent_reports = load_recent_reports()
        for report in recent_reports:
            self.recent_reports_listbox.insert(tk.END, report)
    
    def create_wait_label(self):
        """Create a label to indicate the processing state."""
        self.wait_label = tk.Label(self.root, text="", bg=self.bg_color, fg=self.text_color)
        self.wait_label.grid(row=4, column=1, columnspan=3, padx=10, pady=10, sticky='w')
    
    def create_progress_bar(self):
        """Create a progress bar for long-running operations."""
        self.progress_bar = ttk.Progressbar(self.root, orient='horizontal', length=200, mode='determinate')
        self.progress_bar.grid(row=8, column=0, columnspan=2, padx=10, pady=10, sticky='we')
    
    def update_ui_colors(self):
        """Update the colors of all UI elements."""
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Label) or isinstance(widget, tk.Button):
                widget.configure(bg=self.bg_color, fg=self.text_color)
            elif isinstance(widget, tk.Entry) or isinstance(widget, tk.Listbox) or isinstance(widget, scrolledtext.ScrolledText):
                widget.configure(bg=self.entry_bg, fg=self.text_color)
        
        self.root.configure(bg=self.bg_color)
        self.llm_dropdown.configure(bg=self.entry_bg, fg=self.text_color, highlightbackground=self.entry_bg, highlightcolor=self.text_color)
    
    def analyze_cve(self, *args):
        """Trigger the analysis of a CVE."""
        cve_id = self.cve_id_entry.get()
        if not cve_id:
            messagebox.showerror("Error", "Please enter a CVE ID.")
            return
        
        self.wait_label.config(text="Analyzing CVE, please wait...")
        self.progress_bar['value'] = 0
        
        analyze_cve(cve_id, self.llm_instance, self.display_report, self.update_progress)
    
    def display_report(self, report: str):
        """Display the generated report in the text area."""
        self.text_area.delete(1.0, tk.END)
        self.text_area.insert(tk.END, report)
        self.wait_label.config(text="Analysis complete.")
    
    def update_progress(self, value: int):
        """Update the progress bar."""
        self.progress_bar['value'] = value
    
    def save_report_initial(self):
        """Save the generated report as a text file and PDF."""
        cve_id = self.cve_id_entry.get()
        report = self.text_area.get(1.0, tk.END).strip()
        if not cve_id or not report:
            messagebox.showerror("Error", "Please analyze a CVE and generate a report first.")
            return
    
        if not os.path.exists(REPORTS_DIRECTORY):
            os.makedirs(REPORTS_DIRECTORY)
    
        # Save as text file
        text_file_path = os.path.join(REPORTS_DIRECTORY, f'{cve_id}.txt')
        with open(text_file_path, 'w') as file:
            file.write(report)
    
        # Save as PDF
        pdf_file_path = save_pdf(report, cve_id)
    
        # Update recent reports list
        self.recent_reports_listbox.insert(0, f"{cve_id}.txt")
        self.update_recent_reports_listbox()
        self.wait_label.config(text=f"Report saved as {text_file_path} and {pdf_file_path}.")

    def update_recent_reports_listbox(self):
        """Update the recent reports listbox with the latest reports."""
        recent_reports = load_recent_reports()
        self.recent_reports_listbox.delete(0, tk.END)
        for report in recent_reports:
            self.recent_reports_listbox.insert(tk.END, report)

    
    def on_recent_report_select(self, event):
        """Handle the selection of a recent report."""
        selection = self.recent_reports_listbox.curselection()
        if selection:
            report_file = self.recent_reports_listbox.get(selection[0])
            file_path = os.path.join(REPORTS_DIRECTORY, report_file)
            if report_file.endswith('.pdf'):
                open_pdf_report(file_path)
            else:
                messagebox.showwarning("Warning", "Selected file is not a PDF.")
    
    def clear_input(self):
        """Clear input fields and reset UI state."""
        self.cve_id_entry.delete(0, tk.END)
        self.text_area.delete(1.0, tk.END)
        self.wait_label.config(text="")
        self.progress_bar['value'] = 0

if __name__ == "__main__":
    root = tk.Tk()
    app = CVEAnalyzerApp(root)
    root.minsize(900, 1100)
    root.mainloop()

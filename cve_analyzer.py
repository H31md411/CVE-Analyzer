import tkinter as tk
from tkinter import scrolledtext, messagebox, ttk
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
import os
import requests
from langchain_community.llms.ollama import Ollama
from dotenv import load_dotenv
import threading
import openai
import subprocess
import platform
import logging
from typing import List, Tuple, Optional, Callable, Union
from PIL import Image, ImageTk
import GPUtil  # For GPU monitoring

# Load environment variables from a .env file
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constants
DARK_BG = '#2E2E2E'
DARKER_BG = '#1E1E1E'
LIGHT_BG = '#F0F0F0'
LIGHTER_BG = '#FFFFFF'
DARK_TEXT_COLOR = 'white'
LIGHT_TEXT_COLOR = 'black'
BUTTON_COLOR = '#4CAF50'
BUTTON_COLOR_RED = '#FC6B6B'
REPORTS_DIRECTORY = 'reports'
CVE_API_URL = "https://cve.circl.lu/api/last/10"  # URL to fetch the last 10 CVEs

# Language dictionary
LANGUAGES = {
    'en': {
        'title': "CVE Analyzer Tool",
        'enter_cve': "Enter CVE ID or select from the list:",
        'analyze_button': "Analyze CVE",
        'save_report': "Save Report",
        'recent_reports': "Recent Reports:",
        'select_llm': "Select LLM:",
        'llm_llama': "LLaMA",
        'llm_openai': "OpenAI",
        'wait_analyzing': "Analyzing CVE, please wait...",
        'analysis_complete': "Analysis complete.",
        'error_no_cve': "Please enter a CVE ID.",
        'error_no_report': "Please analyze a CVE and generate a report first.",
        'report_saved': "Report saved as {text_file_path} and {pdf_file_path}.",
        'error_scraping': "Error scraping {url}: {error}",
        'generated_by': "Generated with the CVE Analyzer Tool - by Marcel Graewer 2024",
        'gpu_usage': "GPU Usage: {load:.2f}% | Memory Used: {mem_used}MB / {mem_total}MB",
        'name_label': "Marcel Graewer | 2024",
        'delete_report': "Delete Selected Report",
        'error_no_selection': "Please select a report to delete.",
        'error_no_cve_exists': "The CVE ID {cve_id} does not exist. Please enter a valid CVE ID.",
        'error_invalid_response': "Invalid response from CVE database. Please try again later.",
        'warning_cve_not_exist': "The CVE ID {cve_id} does not exist in the database.",
    },
    'de': {
        'title': "CVE-Analysetool",
        'enter_cve': "Geben Sie die CVE-ID ein oder wählen Sie aus der Liste:",
        'analyze_button': "CVE analysieren",
        'save_report': "Bericht speichern",
        'recent_reports': "Aktuelle Berichte:",
        'select_llm': "LLM auswählen:",
        'llm_llama': "LLaMA",
        'llm_openai': "OpenAI",
        'wait_analyzing': "CVE wird analysiert, bitte warten...",
        'analysis_complete': "Analyse abgeschlossen.",
        'error_no_cve': "Bitte geben Sie eine CVE-ID ein.",
        'error_no_report': "Bitte analysieren Sie eine CVE und erstellen Sie zuerst einen Bericht.",
        'report_saved': "Bericht gespeichert als {text_file_path} und {pdf_file_path}.",
        'error_scraping': "Fehler beim Abrufen {url}: {error}",
        'generated_by': "Erstellt mit dem CVE-Analysetool - von Marcel Graewer 2024",
        'gpu_usage': "GPU-Auslastung: {load:.2f}% | Genutzter Speicher: {mem_used}MB / {mem_total}MB",
        'name_label': "Marcel Graewer | 2024",
        'delete_report': "Ausgewählten Bericht löschen",
        'error_no_selection': "Bitte wählen Sie einen Bericht zum Löschen aus.",
        'error_no_cve_exists': "Die CVE-ID {cve_id} existiert nicht. Bitte geben Sie eine gültige CVE-ID ein.",
        'error_invalid_response': "Ungültige Antwort von der CVE-Datenbank. Bitte versuchen Sie es später erneut.",
        'warning_cve_not_exist': "Die CVE-ID {cve_id} existiert nicht in der Datenbank.",
    }
}

# Initialize LLaMA model
def create_llm_llama() -> Optional[Ollama]:
    try:
        return Ollama(
            model="llama3.1",
            base_url="http://localhost:11434"
        )
    except Exception as e:
        logging.error(f"Error creating LLaMA model: {str(e)}")
        return None

# Initialize OpenAI GPT
def create_llm_openai():
    openai.api_key = os.getenv('OPENAI_API_KEY')
    return openai

def query_llm(prompt: str, llm, language: str, cve_id: str, cve_info: str) -> str:
    """Query the language model with the given prompt."""
    try:
        if isinstance(llm, Ollama):
            response = llm.invoke(prompt)
            return response if isinstance(response, str) else response.get('text', 'No text returned from LLaMA')
        elif llm is openai:
            # Construct the system message based on the selected language
            if language == 'de':
                system_message = (
                    f"Sie sind ein erfahrener Cybersecurity-Analyst mit tiefem Fachwissen in der Bewertung und Minderung von Risiken im Zusammenhang mit Common Vulnerabilities and Exposures (CVEs). Ihre Aufgabe ist es, die bereitgestellten CVE-Informationen gründlich zu analysieren. Ihre Analyse sollte auf ein Unternehmenspublikum zugeschnitten sein, einschließlich technischer Stakeholder."
                    f"Die CVE-Nummer ist: {cve_id}. Hier sind die relevanten Informationen aus der Datenbank: {cve_info}"
                    f"Bitte gehen Sie auf die folgenden Punkte ein und geben Sie nichts anderes als dies aus. Sehr detailliert, halten Sie sich bezüglich der Formatierung zwingend an die Überschriften (**TEXT**) und wenn Sie Listen oder Aufzählungspunkte verwenden (Sie entscheiden, ob es nützlich ist), formatieren Sie sie wie (1. dann 2. und so weiter):"
                    f"**CVE Übersicht:** Beginnen Sie mit einer kurzen Zusammenfassung der CVE, einschließlich ihrer Kennung, Beschreibung und der Art der Schwachstelle (z.B. Pufferüberlauf, SQL-Injektion, etc.)."
                    f"**Technische Analyse:** Tauchen Sie so tief wie möglich in die technischen Aspekte der Schwachstelle ein. Erklären Sie, wie die Schwachstelle ausgenutzt werden kann, einschließlich der Angriffsvektoren, der Voraussetzungen für die Ausnutzung und der potenziellen Auswirkungen auf betroffene Systeme. Die Erklärung sollte technische Details beinhalten und diese erläutern."
                    f"**Auswirkungsbewertung:** Bewerten Sie die potenziellen Auswirkungen der CVE auf die Infrastruktur einer Organisation, unter Berücksichtigung von Faktoren wie Datenverlust, Dienstunterbrechung oder Kompromittierung sensibler Informationen. Diskutieren Sie die Schwere der Schwachstelle anhand einer allgemein akzeptierten Metrik (z.B. CVSS-Score) und beziehen Sie dies auf mögliche geschäftliche Konsequenzen."
                    f"**Mitigation:** Geben Sie äußerst konkrete, spezifische Empfehlungen zur Minderung oder Behebung der Schwachstelle. Vermeiden Sie allgemeine Floskeln und konzentrieren Sie sich auf praktikable Maßnahmen, die direkt auf diese CVE anwendbar sind. Falls es bekannte Links zu Mitigation-Artikeln oder Ressourcen gibt, fügen Sie diese ein."
                    f"**Reale Beispiele:** Falls relevant, verweisen Sie auf reale Vorfälle oder Fallstudien, in denen diese Schwachstelle ausgenutzt wurde. Diskutieren Sie, wie ähnliche Organisationen mit dem Problem umgegangen sind und welche Lehren daraus gezogen wurden."
                    f"**Schlussfolgerung und Folgemaßnahmen:** Schließen Sie mit einer Zusammenfassung der wichtigsten Punkte und spezifischen, auf diese CVE bezogenen Abhilfemaßnahmen ab, um sicherzustellen, dass die Organisation auch in Zukunft gegen diese Schwachstelle geschützt bleibt."
                )

            else:
                system_message = (
                    f"You are an experienced cybersecurity analyst with deep expertise in assessing and mitigating risks associated with Common Vulnerabilities and Exposures (CVEs). Your task is to thoroughly analyze the provided CVE information. Your analysis should be tailored to a corporate audience, including technical stakeholders. The CVE number is: {cve_id}. Here is the relevant information from the database: {cve_info}"
                    f"Please address the following points and output nothing but this, very detailed, stick to the headlines regarding the formatting (**TEXT**) and if you use lists or bullet points (you decide if it is useful) format them like (1. then 2. and so on):"
                    f"**CVE Overview:** Start with a concise summary of the CVE, including its identifier, description, and the nature of the vulnerability (e.g., buffer overflow, SQL injection, etc.)."
                    f"**Technical Analysis:** Dive into as much detail as possible about the technical aspects of the vulnerability. Explain how the vulnerability can be exploited, including the attack vectors, prerequisites for exploitation, and the potential impact on affected systems. The explanation should include and clarify technical details."
                    f"**Impact Assessment:** Evaluate the potential impact of the CVE on an organization's infrastructure, considering factors such as data loss, service disruption, or compromise of sensitive information. Discuss the severity of the vulnerability using a commonly accepted metric (e.g., CVSS score) and relate it to possible business consequences."
                    f"**Mitigation:** Provide extremely concrete, specific recommendations for mitigating or remediating the vulnerability. Avoid general clichés and focus on practical measures that are directly applicable to this CVE. If there are known links to mitigation articles or resources, include them."
                    f"**Real-World Examples:** If relevant, refer to real incidents or case studies where this vulnerability has been exploited. Discuss how similar organizations have handled the issue and what lessons were learned."
                    f"**Conclusion and Follow-up Actions:** Conclude with a summary of the key points and specific, CVE-related remedial actions to ensure the organization remains protected against this vulnerability in the future."
                )
            # Send the system message and prompt to OpenAI
            response = llm.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=4096,
                temperature=0.1
            )

            return response.choices[0].message.content.strip()
        else:
            return 'Unsupported LLM type'
    except Exception as e:
        logging.error(f"Error querying LLM: {str(e)}")
        return f"Error querying LLM: {str(e)}"



def analyze_cve(cve_id: str, llm_instance, callback, progress_callback: Callable[[int], None], language: str):
    """Analyze the given CVE ID using the specified language model."""
    def worker():
        try:
            progress_callback(10)
            cve_url = f"https://cve.circl.lu/api/cve/{cve_id}"
            web_scraper = WebScrapingTool()
            cve_info = web_scraper.scrape(cve_url)
            
            if "Error" in cve_info:
                callback(cve_info)
                return
            progress_callback(50)
            
            if language == 'de':
                llm_prompt = (
                    f"Sie sind ein erfahrener Cybersecurity-Analyst mit tiefem Fachwissen in der Bewertung und Minderung von Risiken im Zusammenhang mit Common Vulnerabilities and Exposures (CVEs). Ihre Aufgabe ist es, die bereitgestellten CVE-Informationen gründlich zu analysieren. Ihre Analyse sollte auf ein Unternehmenspublikum zugeschnitten sein, einschließlich technischer Stakeholder."
                    f"Die CVE-Nummer ist: {cve_id}. Hier sind die relevanten Informationen aus der Datenbank: {cve_info}"
                    f"Bitte gehen Sie auf die folgenden Punkte ein und geben Sie nichts anderes als dies aus. Sehr detailliert, halten Sie sich bezüglich der Formatierung zwingend an die Überschriften (**TEXT**) und wenn Sie Listen oder Aufzählungspunkte verwenden (Sie entscheiden, ob es nützlich ist), formatieren Sie sie wie (1. dann 2. und so weiter):"
                    f"**CVE Übersicht:** Beginnen Sie mit einer kurzen Zusammenfassung der CVE, einschließlich ihrer Kennung, Beschreibung und der Art der Schwachstelle (z.B. Pufferüberlauf, SQL-Injektion, etc.)."
                    f"**Technische Analyse:** Tauchen Sie so tief wie möglich in die technischen Aspekte der Schwachstelle ein. Erklären Sie, wie die Schwachstelle ausgenutzt werden kann, einschließlich der Angriffsvektoren, der Voraussetzungen für die Ausnutzung und der potenziellen Auswirkungen auf betroffene Systeme. Die Erklärung sollte technische Details beinhalten und diese erläutern."
                    f"**Auswirkungsbewertung:** Bewerten Sie die potenziellen Auswirkungen der CVE auf die Infrastruktur einer Organisation, unter Berücksichtigung von Faktoren wie Datenverlust, Dienstunterbrechung oder Kompromittierung sensibler Informationen. Diskutieren Sie die Schwere der Schwachstelle anhand einer allgemein akzeptierten Metrik (z.B. CVSS-Score) und beziehen Sie dies auf mögliche geschäftliche Konsequenzen."
                    f"**Mitigation:** Geben Sie äußerst konkrete, spezifische Empfehlungen zur Minderung oder Behebung der Schwachstelle. Vermeiden Sie allgemeine Floskeln und konzentrieren Sie sich auf praktikable Maßnahmen, die direkt auf diese CVE anwendbar sind. Falls es bekannte Links zu Mitigation-Artikeln oder Ressourcen gibt, fügen Sie diese ein."
                    f"**Reale Beispiele:** Falls relevant, verweisen Sie auf reale Vorfälle oder Fallstudien, in denen diese Schwachstelle ausgenutzt wurde. Diskutieren Sie, wie ähnliche Organisationen mit dem Problem umgegangen sind und welche Lehren daraus gezogen wurden."
                    f"**Schlussfolgerung und Folgemaßnahmen:** Schließen Sie mit einer Zusammenfassung der wichtigsten Punkte und spezifischen, auf diese CVE bezogenen Abhilfemaßnahmen ab, um sicherzustellen, dass die Organisation auch in Zukunft gegen diese Schwachstelle geschützt bleibt."
                )

            else:
                llm_prompt = (f"You are an experienced cybersecurity analyst with deep expertise in assessing and mitigating risks associated with Common Vulnerabilities and Exposures (CVEs). Your task is to thoroughly analyze the provided CVE information. Your analysis should be tailored to a corporate audience, including technical stakeholders. The CVE number is: {cve_id}. Here is the relevant information from the database: {cve_info}"
                    f"Please address the following points and output nothing but this, very detailed, stick to the headlines regarding the formatting (**TEXT**) and if you use lists or bullet points (you decide if it is useful) format them like (1. then 2. and so on):"
                    f"**CVE Overview:** Start with a concise summary of the CVE, including its identifier, description, and the nature of the vulnerability (e.g., buffer overflow, SQL injection, etc.)."
                    f"**Technical Analysis:** Dive into as much detail as possible about the technical aspects of the vulnerability. Explain how the vulnerability can be exploited, including the attack vectors, prerequisites for exploitation, and the potential impact on affected systems. The explanation should include and clarify technical details."
                    f"**Impact Assessment:** Evaluate the potential impact of the CVE on an organization's infrastructure, considering factors such as data loss, service disruption, or compromise of sensitive information. Discuss the severity of the vulnerability using a commonly accepted metric (e.g., CVSS score) and relate it to possible business consequences."
                    f"**Mitigation:** Provide extremely concrete, specific recommendations for mitigating or remediating the vulnerability. Avoid general clichés and focus on practical measures that are directly applicable to this CVE. If there are known links to mitigation articles or resources, include them."
                    f"**Real-World Examples:** If relevant, refer to real incidents or case studies where this vulnerability has been exploited. Discuss how similar organizations have handled the issue and what lessons were learned."
                    f"**Conclusion and Follow-up Actions:** Conclude with a summary of the key points and specific, CVE-related remedial actions to ensure the organization remains protected against this vulnerability in the future."
                )

            
            llm_report = query_llm(llm_prompt, llm_instance, language, cve_id, cve_info)
            
            if "Error" in llm_report:
                callback(llm_report)
                return
            
            progress_callback(100)
            callback(llm_report)
        except Exception as e:
            logging.error(f"Error in analyze_cve: {str(e)}")
            callback(f"Error analyzing CVE: {str(e)}")
    
    threading.Thread(target=worker).start()


def save_pdf(report: str, cve_id: str, language: str) -> str:
    """Save the report as a PDF file with enhanced formatting."""
    file_path = os.path.join(REPORTS_DIRECTORY, f'{cve_id}-{language}.pdf')
    doc = SimpleDocTemplate(file_path, pagesize=letter)
    styles = getSampleStyleSheet()
    
    # Define paragraph styles
    style_title = ParagraphStyle(
        name='Title',
        parent=styles['Title'],
        fontName='Helvetica-Bold',
        fontSize=16,
        spaceAfter=12,
        textColor=colors.darkred,
        alignment=1
    )
    style_heading = ParagraphStyle(
        name='Heading',
        parent=styles['Heading2'],
        fontName='Helvetica-Bold',
        fontSize=14,
        spaceAfter=12,
        textColor=colors.darkgreen
    )
    style_normal = ParagraphStyle(
        name='Normal',
        parent=styles['Normal'],
        fontName='Helvetica',
        fontSize=12,
        leading=14,
        spaceAfter=12,
        textColor=colors.black
    )
    style_bullet = ParagraphStyle(
        name='Bullet',
        parent=styles['Normal'],
        fontName='Helvetica',
        fontSize=12,
        leading=14,
        leftIndent=20,
        spaceBefore=6,
        bulletFontName='Helvetica-Bold',
        bulletFontSize=12,
        bulletIndent=10,
        textColor=colors.black
    )

    elements = []
    title = Paragraph(f"{cve_id}", style_title)
    elements.append(title)
    elements.append(Spacer(1, 12))

    # Section headers mapping based on language
    section_headers = {
        'de': {
            'CVE Overview': '**CVE Übersicht:**',
            'Technical Analysis': '**Technische Analyse:**',
            'Impact Assessment': '**Auswirkungsbewertung:**',
            'Mitigation': '**Mitigation:**',
            'Real-World Examples': '**Reale Beispiele:**',
            'Conclusion and Follow-up Actions': '**Schlussfolgerung und Folgemaßnahmen:**',
        },
        'en': {
            'CVE Overview': '**CVE Overview:**',
            'Technical Analysis': '**Technical Analysis:**',
            'Impact Assessment': '**Impact Assessment:**',
            'Mitigation': '**Mitigation:**',
            'Real-World Examples': '**Real-World Examples:**',
            'Conclusion and Follow-up Actions': '**Conclusion and Follow-up Actions:**',
        }
    }

    # Split the report into sections based on the headers
    sections = report.split('\n\n')
    for section in sections:
        for header_key, header_value in section_headers[language].items():
            if section.startswith(header_value):
                heading = header_value.replace('**', '')
                content = section.replace(header_value, '').strip()
                elements.append(Paragraph(f"{heading}", style_heading))

                # Process bullet points: Identify numerical lists and break them into lines
                bullet_points = []
                lines = content.split('\n')
                for line in lines:
                    if line.strip().startswith(("###","- **","*", "1. **", "2. **", "3. **", "4. **", "5. **","6. **", "- ", "1. ", "2. ", "3. ", "4. ", "5. ","6. ", "**1. ","**2. ","**3. ","**4. ","**5. ","**6. ","1.", "2.", "3.", "4.", "5.","6.","1.  ", "2.  ", "3.  ", "4.  ", "5.  ","6.  ",)):
                        bullet_points.append(Paragraph(line.strip(), style_bullet))
                    elif bullet_points:
                        bullet_points[-1].text += f' {line.strip()}'  

                if bullet_points:
                    elements.extend(bullet_points)
                else:
                    elements.append(Paragraph(content, style_normal))

                elements.append(Spacer(1, 12))
                break  

    elements.append(Spacer(1, 12))
    elements.append(Paragraph(LANGUAGES[language]['generated_by'], style_normal))
    
    doc.build(elements)
    return file_path


def load_recent_reports() -> List[str]:
    """Load the list of recent reports."""
    if not os.path.exists(REPORTS_DIRECTORY):
        os.makedirs(REPORTS_DIRECTORY)
    
    # Filter only .pdf files
    recent_reports = [f for f in os.listdir(REPORTS_DIRECTORY) if f.endswith('.pdf')]
    # Sort by modification time
    recent_reports.sort(key=lambda x: os.path.getmtime(os.path.join(REPORTS_DIRECTORY, x)), reverse=True)
    return recent_reports[:50]

def open_pdf_report(file_path: str):
    """Open the PDF report using the default PDF viewer without a terminal window."""
    try:
        if platform.system() == 'Darwin':  # macOS
            subprocess.run(['open', file_path], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        elif platform.system() == 'Windows':  # Windows
            subprocess.run(['start', file_path], shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=subprocess.CREATE_NO_WINDOW)
        elif platform.system() == 'Linux':  # Linux
            subprocess.run(['xdg-open', file_path], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            messagebox.showerror("Error", "Unsupported OS for opening PDFs.")
    except Exception as e:
        logging.error(f"Failed to open PDF file: {file_path}. Error: {str(e)}")
        messagebox.showerror("Error", f"Failed to open PDF file: {file_path}. Error: {str(e)}")

def fetch_all_cves() -> List[Tuple[str, str, str]]:
    """Fetch the last CVEs from the CVE database, including published date."""
    try:
        response = requests.get(CVE_API_URL)
        response.raise_for_status()
        cve_data = response.json()
        # Extract ID, summary, and published date
        cves = [(entry['id'], entry['summary'], entry['Published']) for entry in cve_data]
        # Sort by published date
        cves.sort(key=lambda x: x[2], reverse=True)
        return cves
    except requests.RequestException as e:
        logging.error(f"Error fetching CVEs: {str(e)}")
        return []

class WebScrapingTool:
    def scrape(self, url: str) -> Union[dict, str]:
        """Scrape the content from the given URL."""
        try:
            response = requests.get(url)
            response.raise_for_status()
            return response.json()  # assuming API returns JSON
        except requests.RequestException as e:
            logging.error(f"Error scraping {url}: {str(e)}")
            return f"Error scraping {url}: {str(e)}"

class CVEAnalyzerApp:
    def __init__(self, root: tk.Tk):
        self.language = 'en'  # Default to English
        self.root = root
        self.llm_type = tk.StringVar(value='openai')  # Default to OpenAI
        self.configure_theme()
        self.root.title(LANGUAGES[self.language]['title'])

        # Language toggle button
        self.toggle_button = tk.Button(self.root, text="Switch to German", command=self.toggle_language, bg=BUTTON_COLOR, fg=self.text_color)
        self.toggle_button.grid(row=0, column=3, padx=10, pady=10, sticky='e')

        # Initialize LLM instance
        self.llm_instance = create_llm_openai()

        # Load all CVEs
        self.all_cves = fetch_all_cves()

        self.create_gui_elements()
        self.update_ui_texts()  # Update UI texts based on selected language

    def configure_theme(self, dark_mode: bool = True):
        """Configure the theme for the application."""
        self.bg_color = '#2E2E2E' if dark_mode else '#F0F0F0'
        self.text_color = 'white' if dark_mode else 'black'
        self.entry_bg = '#1E1E1E' if dark_mode else '#FFFFFF'
        self.radio_bg = '#3E3E3E' if dark_mode else '#DDDDDD'
        self.radio_indicator_color = '#000000'
        self.root.configure(bg=self.bg_color)

    def toggle_language(self):
        """Toggle between English and German."""
        if self.language == 'en':
            self.language = 'de'
            self.toggle_button.config(text="Switch to English")
        else:
            self.language = 'en'
            self.toggle_button.config(text="Switch to German")

        self.update_ui_texts()

    def update_ui_texts(self):
        """Update all UI texts based on the current language."""
        self.root.title(LANGUAGES[self.language]['title'])
        self.title_label.config(text=LANGUAGES[self.language]['title'])
        self.label.config(text=LANGUAGES[self.language]['enter_cve'])
        self.analyze_button.config(text=LANGUAGES[self.language]['analyze_button'])
        self.save_button.config(text=LANGUAGES[self.language]['save_report'])
        self.recent_reports_label.config(text=LANGUAGES[self.language]['recent_reports'])
        self.llm_label.config(text=LANGUAGES[self.language]['select_llm'])
        self.llm_llama_radio.config(text=LANGUAGES[self.language]['llm_llama'])
        self.llm_openai_radio.config(text=LANGUAGES[self.language]['llm_openai'])
        self.name_label.config(text=LANGUAGES[self.language]['name_label'])
        self.delete_button.config(text=LANGUAGES[self.language]['delete_report'])

    def create_gui_elements(self):
        """Create and arrange GUI elements."""
        self.configure_grid()
        self.create_title()
        self.create_input_area()
        self.create_llm_selection()
        self.create_cve_list()
        self.create_text_area()
        self.create_save_button()
        self.create_recent_reports_list()
        self.create_wait_label()
        self.create_progress_bar()
        # Create GPU Usage Label
        self.gpu_usage_label = tk.Label(self.root, text="GPU Usage: 0%", bg=self.bg_color, fg=self.text_color)
        self.gpu_usage_label.grid(row=9, column=0, columnspan=3, padx=10, pady=10, sticky='w')
        # Create Name Label (Bottom Right)
        self.name_label = tk.Label(self.root, text=LANGUAGES[self.language]['name_label'], bg=self.bg_color, fg=self.text_color)
        self.name_label.grid(row=9, column=3, padx=10, pady=10, sticky='e')
        # Add Delete Button
        self.delete_button = tk.Button(self.root, text=LANGUAGES[self.language]['delete_report'], command=self.delete_selected_report, bg=BUTTON_COLOR_RED, fg=self.text_color)
        self.delete_button.grid(row=7, column=0, columnspan=2, padx=10, pady=10, sticky='we')

    def configure_grid(self):
        """Configure the grid layout."""
        for i in range(3):
            tk.Grid.columnconfigure(self.root, i, weight=1)
        for i in range(8):
            tk.Grid.rowconfigure(self.root, i, weight=1)

    def create_title(self):
        """Create the title label."""
        self.title_label = tk.Label(self.root, text=LANGUAGES[self.language]['title'], font=("Arial", 16), bg=self.bg_color, fg=self.text_color)
        self.title_label.grid(row=0, column=0, columnspan=3, padx=10, pady=10, sticky='w')

    def create_input_area(self):
        """Create the input area for CVE ID with filtering."""
        self.label = tk.Label(self.root, text=LANGUAGES[self.language]['enter_cve'], bg=self.bg_color, fg=self.text_color)
        self.label.grid(row=1, column=0, padx=10, pady=10, sticky='w')

        self.cve_id_entry = tk.Entry(self.root, bg=self.entry_bg, fg=self.text_color)
        self.cve_id_entry.grid(row=1, column=1, padx=10, pady=10, sticky='we')
        self.cve_id_entry.bind('<KeyRelease>', self.on_cve_id_entry_change)

        self.analyze_button = tk.Button(self.root, text=LANGUAGES[self.language]['analyze_button'], command=self.analyze_cve, bg=BUTTON_COLOR, fg=self.text_color)
        self.analyze_button.grid(row=1, column=2, padx=10, pady=10, sticky='w')

    def create_cve_list(self):
        """Create the CVE listbox to display CVEs."""
        self.cve_listbox = tk.Listbox(self.root, bg=self.entry_bg, fg=self.text_color, selectbackground=BUTTON_COLOR)
        self.cve_listbox.grid(row=2, column=0, columnspan=4, padx=10, pady=10, sticky='nsew')
        self.cve_listbox.bind('<<ListboxSelect>>', self.on_cve_select)

        # Insert CVEs into listbox
        for cve_id, summary, published in self.all_cves:
            self.cve_listbox.insert(tk.END, f"{cve_id}: {published} -- {summary}")

    def filter_cve_list(self, event):
        """Filter the CVE list based on input."""
        filter_text = self.cve_id_entry.get().lower()
        self.cve_listbox.delete(0, tk.END)

        for cve_id, summary, published in self.all_cves:
            if filter_text in cve_id.lower() or filter_text in summary.lower():
                self.cve_listbox.insert(tk.END, f"{cve_id}: {published} -- {summary}")

    def on_cve_id_entry_change(self, event):
        """Handle CVE ID entry change and fetch data if not in the list."""
        cve_id = self.cve_id_entry.get().strip()
        if not any(cve_id in item for item in self.cve_listbox.get(0, tk.END)):
            # Fetch the CVE information if not in the list
            try:
                response = requests.get(f"https://cve.circl.lu/api/cve/{cve_id}")
                if response.status_code == 200 and "summary" in response.json():
                    cve_data = response.json()
                    summary = cve_data.get("summary", "")
                    published = cve_data.get("Published", "")
                    # Add to the list
                    self.cve_listbox.insert(tk.END, f"{cve_id}: {published} -- {summary}")
                else:
                    messagebox.showwarning("Warning", LANGUAGES[self.language]['warning_cve_not_exist'].format(cve_id=cve_id))
            except requests.RequestException:
                messagebox.showerror("Error", LANGUAGES[self.language]['error_invalid_response'])

    def on_cve_select(self, event):
        """Handle CVE selection from the list."""
        selection = self.cve_listbox.curselection()
        if selection:
            cve_data = self.cve_listbox.get(selection[0])
            cve_id = cve_data.split(":")[0].strip()
            self.cve_id_entry.delete(0, tk.END)
            self.cve_id_entry.insert(0, cve_id)

    def create_llm_selection(self):
        """Create the LLM selection with radio buttons."""
        self.llm_frame = tk.Frame(self.root, bg=self.bg_color)
        self.llm_frame.grid(row=1, column=3, columnspan=1, padx=10, pady=10, sticky='w')

        self.llm_label = tk.Label(self.llm_frame, text=LANGUAGES[self.language]['select_llm'], bg=self.bg_color, fg=self.text_color)
        self.llm_label.grid(row=0, column=0, padx=10, pady=10, sticky='w')

        self.llm_llama_radio = tk.Radiobutton(
            self.llm_frame,
            text=LANGUAGES[self.language]['llm_llama'],
            variable=self.llm_type,
            value='llama',
            command=self.on_llm_change,
            bg=self.radio_bg,
            fg=self.text_color,
            selectcolor=self.radio_indicator_color,
            indicatoron=1,
            width=15
        )
        self.llm_llama_radio.grid(row=1, column=0, padx=10, pady=5, sticky='w')

        self.llm_openai_radio = tk.Radiobutton(
            self.llm_frame,
            text=LANGUAGES[self.language]['llm_openai'],
            variable=self.llm_type,
            value='openai',
            command=self.on_llm_change,
            bg=self.radio_bg,
            fg=self.text_color,
            selectcolor=self.radio_indicator_color,
            indicatoron=1,
            width=15
        )
        self.llm_openai_radio.grid(row=2, column=0, padx=10, pady=5, sticky='w')

    def on_llm_change(self):
        """Handle changes in LLM selection."""
        llm_type = self.llm_type.get()
        if llm_type == 'llama':
            self.llm_instance = create_llm_llama()
        elif llm_type == 'openai':
            self.llm_instance = create_llm_openai()

    def create_text_area(self):
        """Create the scrolled text area for displaying the report."""
        self.text_area = scrolledtext.ScrolledText(self.root, wrap=tk.WORD, bg=self.entry_bg, fg=self.text_color)
        self.text_area.grid(row=4, column=0, columnspan=4, padx=10, pady=10, sticky='nsew')

    def create_save_button(self):
        """Create the save button with an icon."""
        self.save_button_icon = Image.open("pdf.png")
        self.save_button_icon = self.save_button_icon.resize((24, 24), Image.Resampling.BICUBIC)
        self.save_button_icon = ImageTk.PhotoImage(self.save_button_icon)

        self.save_button = tk.Button(
            self.root,
            text=LANGUAGES[self.language]['save_report'],
            command=self.save_report_initial,
            bg=BUTTON_COLOR,
            fg=self.text_color,
            image=self.save_button_icon,
            compound=tk.LEFT  # Text will be shown next to the icon
        )
        self.save_button.grid(row=5, column=3, padx=10, pady=10, sticky='e')

    def create_recent_reports_list(self):
        """Create the listbox to display recent reports."""
        self.recent_reports_label = tk.Label(self.root, text=LANGUAGES[self.language]['recent_reports'], bg=self.bg_color, fg=self.text_color)
        self.recent_reports_label.grid(row=5, column=0, padx=10, pady=10, sticky='w')

        self.recent_reports_listbox = tk.Listbox(self.root, bg=self.entry_bg, fg=self.text_color, selectbackground=BUTTON_COLOR)
        self.recent_reports_listbox.grid(row=6, column=0, columnspan=2, padx=10, pady=10, sticky='nsew')
        self.recent_reports_listbox.bind('<Double-1>', self.on_recent_report_select)  # Bind to double-click

        # Populate with recent reports
        recent_reports = load_recent_reports()
        for report in recent_reports:
            self.recent_reports_listbox.insert(tk.END, report)

    def create_wait_label(self):
        """Create a label to indicate the processing state."""
        self.wait_label = tk.Label(self.root, text="", bg=self.bg_color, fg=self.text_color)
        self.wait_label.grid(row=4, column=1, columnspan=3, padx=10, pady=10, sticky='w')

    def create_progress_bar(self):
        """Create a progress bar for long-running operations."""
        self.progress_bar = ttk.Progressbar(self.root, orient='horizontal', length=200, mode='determinate')
        self.progress_bar.grid(row=8, column=0, columnspan=2, padx=10, pady=10, sticky='we')

    def analyze_cve(self, *args):
        """Trigger the analysis of a CVE."""
        cve_id = self.cve_id_entry.get()
        if not cve_id:
            messagebox.showerror("Error", LANGUAGES[self.language]['error_no_cve'])
            return

        self.wait_label.config(text=LANGUAGES[self.language]['wait_analyzing'])
        self.progress_bar['value'] = 0

        analyze_cve(cve_id, self.llm_instance, self.display_report, self.update_progress, self.language)

    def display_report(self, report: str):
        """Display the generated report in the text area."""
        self.text_area.delete(1.0, tk.END)
        self.text_area.insert(tk.END, report)
        self.wait_label.config(text=LANGUAGES[self.language]['analysis_complete'])

    def update_progress(self, value: int):
        """Update the progress bar."""
        self.progress_bar['value'] = value

    def save_report_initial(self):
        """Save the generated report as a text file and PDF."""
        cve_id = self.cve_id_entry.get()
        report = self.text_area.get(1.0, tk.END).strip()
        if not cve_id or not report:
            messagebox.showerror("Error", LANGUAGES[self.language]['error_no_report'])
            return

        if not os.path.exists(REPORTS_DIRECTORY):
            os.makedirs(REPORTS_DIRECTORY)

        text_file_path = os.path.join(REPORTS_DIRECTORY, f'{cve_id}.txt')
        with open(text_file_path, 'w') as file:
            file.write(report)

        # Save as PDF with the selected language
        pdf_file_path = save_pdf(report, cve_id, self.language)

        # Update recent reports list
        self.recent_reports_listbox.insert(0, f"{cve_id}.txt")
        self.update_recent_reports_listbox()
        self.wait_label.config(text=LANGUAGES[self.language]['report_saved'].format(text_file_path=text_file_path, pdf_file_path=pdf_file_path))


    def update_recent_reports_listbox(self):
        """Update the recent reports listbox with the latest reports."""
        recent_reports = load_recent_reports()
        self.recent_reports_listbox.delete(0, tk.END)
        for report in recent_reports:
            self.recent_reports_listbox.insert(tk.END, report)

    def on_recent_report_select(self, event):
        """Handle the selection of a recent report."""
        selection = self.recent_reports_listbox.curselection()
        if selection:
            report_file = self.recent_reports_listbox.get(selection[0])
            file_path = os.path.join(REPORTS_DIRECTORY, report_file)
            if report_file.endswith('.pdf'):
                open_pdf_report(file_path)
            else:
                messagebox.showwarning("Warning", "Selected file is not a PDF.")

    def delete_selected_report(self):
        """Delete the selected report from the list and the file system."""
        selection = self.recent_reports_listbox.curselection()
        if not selection:
            messagebox.showerror("Error", LANGUAGES[self.language]['error_no_selection'])
            return

        report_file = self.recent_reports_listbox.get(selection[0])
        file_path = os.path.join(REPORTS_DIRECTORY, report_file)

        try:
            os.remove(file_path)
            self.recent_reports_listbox.delete(selection[0])
            messagebox.showinfo("Info", f"{report_file} has been deleted.")
        except Exception as e:
            logging.error(f"Failed to delete file: {file_path}. Error: {str(e)}")
            messagebox.showerror("Error", f"Failed to delete {report_file}. Error: {str(e)}")

    def clear_input(self):
        """Clear input fields and reset UI state."""
        self.cve_id_entry.delete(0, tk.END)
        self.text_area.delete(1.0, tk.END)
        self.wait_label.config(text="")
        self.progress_bar['value'] = 0

if __name__ == "__main__":
    root = tk.Tk()
    app = CVEAnalyzerApp(root)
    root.minsize(900, 1100)
    root.mainloop()
